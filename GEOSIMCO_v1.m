% GEOSIMCO Analyzer- Geometric similarity based software to analyze three-dimensional fluorescence patterns                    
%
%   This program is designed to automatically navigate through a folder tree to automatically load  
%   stored *.lif files in them and open all the images contained.    
%   For every image the software detect all the colonies with circular symmetry, retrieve their fluorescent    
%   profile using two representations as representative of the whole colony: XY sum projection and the XZ plane (Y=0)
%
%   After retrieving the XY and XZ profiles of every detected colony, they are spatially mapped to a normalized domain     
%   X[-1 1], Y[-1,1], Z[0,1] using the Radius and Height of every colony. Then intensity values in a fixed grid of reference   
%   is generated by a cubic interpolation using a Delaunay triangulation onto the given set of points for every colony. 
%
%   The interpolated data is stored into three-dimensional matrices to finally generate statistic in every point of the
%   reference grid. The program finally plots this data with three types of figures:
%   Raw fluorescence, normalized heatmaps and Coefficient of variation    
%
%   INPUT:
%
%   Files to be analyzed containing different type of samples (samples,positive and negative control )  
%       
%   OUTPUT
% 
%   Statistics for a reference grid with fixed spatial positions.
%
%
%   WARNINGS
% 
%   The script detect all the subfolders within the folder where the script is present. bfmatlab
%   library is also included, thus ensure that all your folders are listed
%   first when dir command is called and the number of folders is properly modified. Otherwise the program will try to
%   navigate within the library folder
%
%
% The MIT License (MIT)
% 
% Copyright (c) 2019 David R. Espeso
% 
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
% 
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.
% 
%   $Version: 1.0 $  $Date: 2019/05/16 $
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clc
clear

%%% Add current path to MATLAB working directory tree  
file_path_root= pwd;
addpath(file_path_root);

%%% Add current path to MATLAB working directory tree  
addpath([file_path_root '\bfmatlab']);
%addpath([file_path_root '\bfmatlab\bfmatlab']);

%%% Interpolant grid size
resolution_size_xy=256;
resolution_size_z=10;

%%% Colormaps
map_cherry = 'jet';
map_gfp = 'jet';

%%% Create unit disk coordinates with resolution_size in polar and cartesian coordinates  
r=0:1/(resolution_size_xy-1):1;
phi=-pi:2*pi/(resolution_size_xy-1):pi;
z=0:1/(resolution_size_z-1):1;
x=-1:2/(resolution_size_xy-1):1;
[R,PHI]=meshgrid(r,phi);
[X_slice,Z_slice]=meshgrid(x,z);

X_circle=R.*cos(PHI);
Y_circle=R.*sin(PHI);

%%% ALLOCATE STORING VARIABLES IN XY PLANE
norm_radial_profile_gfp_Sin_Cmin=[];
norm_radial_profile_gfp_Sin_Cplus=[];
norm_radial_profile_gfp_Sin_M=[];

norm_radial_profile_cherry_Sin_Cmin=[];
norm_radial_profile_cherry_Sin_Cplus=[];
norm_radial_profile_cherry_Sin_M=[];

%%% ALLOCATE STORING VARIABLES IN XZ PLANE
norm_slice_profile_gfp_Sin_Cmin=[];
norm_slice_profile_gfp_Sin_Cplus=[];
norm_slice_profile_gfp_Sin_M=[];

norm_slice_profile_cherry_Sin_Cmin=[];
norm_slice_profile_cherry_Sin_Cplus=[];
norm_slice_profile_cherry_Sin_M=[];

%%% Obtener el numero de directorios en los que están contenidos mis ficheros    
%%% Gather the number of directories containing the images to process
box=dir;
filess=0;
[ box ] = removepoints_v1( box,filess );  % Remove "fake" directories .. and .

%%% Number of folders to analyze corresponding to every biological repetition     
ndates=2;

for k=1:ndates
    %%% Enter into the selected folder
    cd(box(k).name);
    
    %%% explore subfolder looking for different conditions (each one in a separated folder )
    box2=dir;
    filess=1; % number of real subfolders
    [ box2 ] = removepoints_v1( box2,filess );  % Remove "fake" directories .. and .
    
    for m=1:size(box2,1)
        %%% Enter into the selected folder
        cd(box2(m).name);
        
        %%% explore subfolder looking for different conditions (each one in a separated folder )
        box3=dir;
        filess=1; % number of real subfolders
        [ box3 ] = removepoints_v1( box3,filess );  % Remove "fake" directories .. and .
        
        %%% Gather the number of files within the subfolder
        nfiles=size(box3,1);
        flagg=0;
        
        for n=1:nfiles
            %%% write the path of the file to open in a file_name char variable
            file_path= pwd;
            file_path=[file_path '\'  box3(n).name];
            
            %%% open lif "file_path" and store all information in variable "data"
            data = bfopen(file_path);
            
            %%% Gather the number of images within the *.lif file
            nimages=size(data,1);
            
            %%% For every detected image
            for i=1:nimages
                %%% Extract the size of the image stack
                sizee=size(data{i,1},1);
                %%% Load the 3D stack into a 3D matrix (one for GFP and other for mCherry)
                aux=1;
                matrix_cherry=[];
                matrix_gfp=[];
                for j=1:2:sizee-1
                    matrix_gfp(:,:,aux)=data{i,1}{j,1};
                    matrix_cherry(:,:,aux)=data{i,1}{j+1,1};
                    aux=aux+1;
                end
                %%% Compute sum/mean Z-projection matrix (**0**)
                proy_gfp_sum = sum(matrix_gfp,3);
                proy_cherry_sum = sum(matrix_cherry,3);
                
                proy_gfp_mean = mean(matrix_gfp,3);
                proy_cherry_mean = mean(matrix_cherry,3);
                
                %%% Create mask to remove background noise for both channels. Apply a MASK THRESHOLD VALUE (**1**)         
                thres_ratio=1.10; % Modify manually to adjust masking process
                mask_gfp= proy_gfp_sum>thres_ratio*mean(mean(proy_gfp_sum));
                mask_cherry= proy_cherry_sum>thres_ratio*mean(mean(proy_cherry_sum));

                %%%  Label masks and compute centroids, areas, orientation and major/minor axis lengths for both channels                 
                [L1,~] = bwlabel(mask_gfp);
                [L2,~] = bwlabel(mask_cherry);
                stats_gfp = regionprops('table',L1, 'Area','Orientation','Centroid',...
                    'MajorAxisLength','MinorAxisLength');
                stats_cherry = regionprops('table',L2, 'Area','Orientation','Centroid',...
                    'MajorAxisLength','MinorAxisLength');
                
                %%% Asign an ID tag to each detected object
                stats_gfp.Id=(1:size(stats_gfp,1))';
                stats_cherry.Id=(1:size(stats_cherry,1))';
                
                %%% Remove all objects with an area smaller than a chosen value ==> Adjust size Threshold (**2**)                    
                radius_threshold=20;
                area_threshold=pi*radius_threshold^2;  %%% unidades == píxeles cuadrados
                stats_gfp(stats_gfp.Area<pi()*radius_threshold^2,:)=[];
                stats_cherry(stats_cherry.Area<pi()*radius_threshold^2,:)=[];
                
                %%% Round the centroid and axis lengths to the closest entire integer                   
                stats_gfp.Centroid=round(stats_gfp.Centroid);
                stats_gfp.MajorAxisLength=ceil(stats_gfp.MajorAxisLength);
                stats_gfp.MinorAxisLength=ceil(stats_gfp.MinorAxisLength);
                
                stats_cherry.Centroid=round(stats_cherry.Centroid);
                stats_cherry.MajorAxisLength=ceil(stats_cherry.MajorAxisLength);
                stats_cherry.MinorAxisLength=ceil(stats_cherry.MinorAxisLength);
                
                %%% Check which GFP colonies matches with which cherry colonies by checking their centroids and update their connector ID     
                stats_gfp.IdLink=zeros(size(stats_gfp,1),1);
                stats_cherry.IdLink=zeros(size(stats_cherry,1),1);
                
                size_list_gfp=size(stats_gfp,1);
                size_list_cherry=size(stats_cherry,1);
                remaining_cherry=1:size_list_cherry;
                matching_cherry=zeros(numel(remaining_cherry),1);
                
                for b=1:size_list_gfp
                    for bb=1:size_list_cherry
                        if abs(stats_gfp.Centroid(b)-stats_cherry.Centroid(bb)) <= 6 && abs(stats_gfp.Centroid(b+size_list_gfp)-stats_cherry.Centroid(bb+size_list_cherry)) <= 6 && matching_cherry(bb)==0
                            stats_gfp.IdLink(b)=stats_cherry.Id(bb);
                            stats_cherry.IdLink(bb)=stats_gfp.Id(b);
                            matching_cherry(bb)=1;
                            break
                        end
                    end
                end
                
                %%% Remove all those inputs in object lists that do not have any matching in both lists       
                stats_gfp(stats_gfp.IdLink==0,:)=[];
                stats_cherry(stats_cherry.IdLink==0,:)=[];
                
                %%% Order list rows in descending directions according to ID GFP. In cherry list the ordering will be according to IDlink to match objects in both lists to the same list position                    
                stats_gfp=sortrows(stats_gfp,-6);
                stats_cherry=sortrows(stats_cherry,-7);
                
                %%% For each detected colony, choose the largest MajorAxisLength from both channels (GPF / mCherry) 
                %%% Discard those objects with an axis ratio larger than a chosen threshold (to avoid deformed geometries) (**3**)         
                
                axis_ratio_threshold=1.15;
                discard=[];
                radius=[];
                slopes=[];
                
                for b=1:size(stats_gfp,1)
                    if table2array(stats_gfp(b,1))> table2array(stats_cherry(b,1))
                        if (stats_gfp.MajorAxisLength(b)/stats_gfp.MinorAxisLength(b)>axis_ratio_threshold)
                            discard=[discard b];
                        else
                            radius=[radius 0.5*mean([stats_gfp.MajorAxisLength(b) stats_gfp.MinorAxisLength(b)]) ];
                            slopes=[slopes tan(stats_gfp.Orientation(b)*2*pi/360)]; % cuantos píxeles me tengo que mover en Y al desplazarme +1 pixel en X
                        end
                    else
                        if (stats_cherry.MajorAxisLength(b)/stats_cherry.MinorAxisLength(b)>axis_ratio_threshold)
                            discard=[discard b];
                        else
                            radius=[radius 0.5*mean([stats_cherry.MajorAxisLength(b) stats_cherry.MinorAxisLength(b)]) ];
                            slopes=[slopes tan(stats_cherry.Orientation(b)*2*pi/360)]; % cuantos píxeles me tengo que mover en Y al desplazarme +1 pixel en X
                        end
                    end
                end
                stats_gfp(discard,:)=[];
                stats_cherry(discard,:)=[];
                
                %%%% If list is not empty, compute
                
                if ~isempty(stats_gfp)
                    
                    %%% Allocate auxiliary matrices
                    norm_radial_profile_gfp=[];
                    norm_radial_profile_cherry=[];
                    
                    norm_slice_profile_gfp=[];
                    norm_slice_profile_cherry=[];
                    
                    %%% For each detected body, gather the indices of the pixels forming its XY projection and extract the fluorescent values  
                    sizemat=size(L1);
                    for b=1:size(stats_gfp,1)
                        if stats_gfp.Area(b)> stats_cherry.Area(b)
                            elems=find(L1==stats_gfp.Id(b));
                            centerx=stats_gfp.Centroid(b);
                            centery=stats_gfp.Centroid(b+size(stats_gfp,1));
                            [ymat_ellip,xmat_ellip] = ind2sub(sizemat,elems);
                            fmat_ellip_gfp=proy_gfp_sum(elems);
                            % fmat_ellip_gfp=proy_gfp_mean(elems);
                            fmat_ellip_cherry=proy_cherry_sum(elems);
                        else
                            elems=find(L2==stats_cherry.Id(b));
                            centerx=stats_cherry.Centroid(b);
                            centery=stats_cherry.Centroid(b+size(stats_cherry,1));
                            [ymat_ellip,xmat_ellip] = ind2sub(sizemat,elems);
                            fmat_ellip_gfp=proy_gfp_sum(elems);
                            % fmat_ellip_gfp=proy_gfp_mean(elems);
                            fmat_ellip_cherry=proy_cherry_sum(elems);
                        end
                        
                        %%%% Compute interpolation in XY profile
                        [ vq_gfp ] = norm_surface_colony_v3(xmat_ellip,ymat_ellip,fmat_ellip_gfp,X_circle,Y_circle,radius(b),centerx,centery);
                        [ vq_cherry ] = norm_surface_colony_v3(xmat_ellip,ymat_ellip,fmat_ellip_cherry,X_circle,Y_circle,radius(b),centerx,centery);
                        
                        %%% Store interpolated values into a 3D matrix
                        if flagg == 0
                            norm_radial_profile_gfp(:,:,b)=vq_gfp;
                            norm_radial_profile_cherry(:,:,b)=vq_cherry;
                        elseif flagg == 1
                            norm_radial_profile_gfp(:,:,b)=(vq_gfp);%/max(max(vq_gfp));%(vq_gfp-cminus_radial_gfp)./(cplus_radial_gfp-cminus_radial_gfp);
                            norm_radial_profile_cherry(:,:,b)=vq_cherry;%/max(max(vq_cherry));
                        end
                        
                        %%%% Compute interpolation in Z slice profile
                        %%% Select the elements chosen in the diameter plane y= Center Y  
                        chosen=find(ymat_ellip==centery);
                        xchosen=xmat_ellip(chosen);
                        zchosen=1:size(matrix_gfp,3);
                        
                        %%% Prepare coordinate matrices of points to consider
                        xmat_plane_z=repelem(xmat_ellip(chosen),size(matrix_gfp,3));
                        zmat_plane_z=repmat((1:size(matrix_gfp,3))',numel(chosen),1);
                        
                        fmat_gfp_plane_z=[];
                        fmat_cherry_plane_z=[];
                        
                        %%% Gather data from chosen XZ plane for both channels 
                        for kkk=1:size(matrix_gfp,3)
                            fmat_gfp_plane_z(kkk,1:numel(xchosen))=matrix_gfp(centery,xchosen,kkk);
                            fmat_cherry_plane_z(kkk,1:numel(xchosen))=matrix_cherry(centery,xchosen,kkk);
                        end
                        
                        %%% Create mask to remove background noise for both channels        
                        mask_plane_z_gfp= fmat_gfp_plane_z>thres_ratio*mean(mean(fmat_gfp_plane_z));
                        mask_plane_z_cherry= fmat_cherry_plane_z>thres_ratio*mean(mean(fmat_cherry_plane_z));
                        
                        %%%  Label masks and compute centroids, areas, orientation and major/minor axis lengths for both channels                 
                        [LL1,~] = bwlabel(mask_plane_z_gfp);
                        [LL2,~] = bwlabel(mask_plane_z_cherry);
                        stats_z_plane_gfp = regionprops('table',LL1, 'Area','Orientation','Centroid',...
                            'MajorAxisLength','MinorAxisLength');
                        stats_z_plane_cherry = regionprops('table',LL2, 'Area','Orientation','Centroid',...
                            'MajorAxisLength','MinorAxisLength');
                        %%% Select the largest object in area of the stat_z_plane ==> the colony
                        chosenn=find(stats_z_plane_cherry.Area==max(stats_z_plane_cherry.Area));
                        
                        %%% Detect the orientation of the object and rotate the reference frame to align the major axis with X axis        
                        %%% Take the mask with the largest area value detected in both channels (GFP / mCherry) 
                        if stats_z_plane_cherry.Area(chosenn) >= stats_z_plane_cherry.Area(chosenn)
                            %%% center
                            centerx_slice=xchosen(round(stats_z_plane_cherry.Centroid(chosenn)));
                            centerz_slice=zchosen(round(stats_z_plane_cherry.Centroid(chosenn+size(stats_z_plane_cherry,1))));
                            
                            %%% Obtain lineal coordinates of matrix elements      
                            chosen2=find(LL2==chosenn);
                            
                            %%% Obtain X and Z coordinates of the selected points, and harvest intensity values contained on them      
                            zmat_ellip_slice=zmat_plane_z(chosen2);
                            xmat_ellip_slice=xmat_plane_z(chosen2);
                            fmat_ellip_slice_cherry=fmat_cherry_plane_z(chosen2);
                            fmat_ellip_slice_gfp=fmat_gfp_plane_z(chosen2);
                            
                            %%% Take the rotation angle
                            theta=stats_z_plane_cherry.Orientation(chosenn)*pi/180;
                            
                            %%% Evaluate the rotation matrix and flip points      
                            R=[cos(theta) -sin(theta);sin(theta) cos(theta)];
                            points_rotated=R*([xmat_ellip_slice zmat_ellip_slice]');
                            xmat_ellip_slice_rot=points_rotated(1,:)';
                            zmat_ellip_slice_rot=points_rotated(2,:)';
                        else
                            %%% center
                            centerx_slice=xchosen(round(stats_z_plane_gfp.Centroid(chosenn)));
                            centerz_slice=zchosen(round(stats_z_plane_gfp.Centroid(chosenn+size(stats_z_plane_cherry,1))));
                            
                            %%% Obtain lineal coordinates of matrix elements      
                            chosen2=find(LL1==chosenn);
                            
                            %%% Obtain X and Z coordinates of the selected points, and harvest intensity values contained on them      
                            zmat_ellip_slice=zmat_plane_z(chosen2);
                            xmat_ellip_slice=xmat_plane_z(chosen2);
                            fmat_ellip_slice_cherry=fmat_cherry_plane_z(chosen2);
                            fmat_ellip_slice_gfp=fmat_gfp_plane_z(chosen2);
                            
                            %%% Take the rotation angle
                            theta=stats_z_plane_cherry.Orientation(chosenn)*pi/180;
                            
                            %%% Evaluate the rotation matrix and flip points      
                            R=[cos(theta) -sin(theta);sin(theta) cos(theta)];
                            points_rotated=R*([xmat_ellip_slice zmat_ellip_slice]');
                            xmat_ellip_slice_rot=points_rotated(1,:)';
                            zmat_ellip_slice_rot=points_rotated(2,:)';
                        end
                        
                        %%% normalize X and Z axis coordinates 
                        xmat_ellip_slice_rot=(xmat_ellip_slice_rot-centerx_slice)/max(xmat_ellip_slice_rot-centerx_slice);
                        zmat_ellip_slice_rot=(zmat_ellip_slice_rot-min(zmat_ellip_slice_rot))/(max(zmat_ellip_slice_rot-min(zmat_ellip_slice_rot)));
                        
                        %%% Interpolate values in normalized query points [X_circle,Y_circle] from values pixel_int positioned in [pixel_posx,pixel_posy]
                        vq_cherry_slice = griddata(xmat_ellip_slice_rot,zmat_ellip_slice_rot,fmat_ellip_slice_cherry,X_slice,Z_slice,'cubic');
                        vq_gfp_slice = griddata(xmat_ellip_slice_rot,zmat_ellip_slice_rot,fmat_ellip_slice_gfp,X_slice,Z_slice,'cubic');
                        

                        %%%% NORMALIZE DISCOUNTING NEGATIVE AND POSITIVE CONTROL
                        if flagg == 0
                            norm_slice_profile_gfp(:,:,b)=vq_gfp_slice;
                            norm_slice_profile_cherry(:,:,b)=vq_cherry_slice;
                        elseif flagg == 1
                            norm_slice_profile_gfp(:,:,b)=(vq_gfp_slice);%/max(max(vq_gfp_slice));%(cplus_slice_gfp-cminus_slice_gfp);
                            norm_slice_profile_cherry(:,:,b)=(vq_cherry_slice);%/max(max(vq_cherry_slice));
                        end
                        
                    end
                    
                    %%% Concatenate 3D matrix depending on the type of sample (C-, C+, M) // (Sin => No humidity) // (P35 ==> 120 h)     
                    if contains(file_path,'P35')  %%% 120 h
                        if contains(file_path,'Sin')  %%% Sin Humedad
                            if contains(file_path,'C-')
                                norm_radial_profile_gfp_Sin_Cmin=cat(3,norm_radial_profile_gfp_Sin_Cmin,norm_radial_profile_gfp);
                                norm_radial_profile_cherry_Sin_Cmin=cat(3,norm_radial_profile_cherry_Sin_Cmin,norm_radial_profile_cherry);
                                norm_slice_profile_gfp_Sin_Cmin=cat(3,norm_slice_profile_gfp_Sin_Cmin,norm_slice_profile_gfp);
                                norm_slice_profile_cherry_Sin_Cmin=cat(3,norm_slice_profile_cherry_Sin_Cmin,norm_slice_profile_cherry);
                            elseif contains(file_path,'C+')
                                norm_radial_profile_gfp_Sin_Cplus=cat(3,norm_radial_profile_gfp_Sin_Cplus,norm_radial_profile_gfp);
                                norm_radial_profile_cherry_Sin_Cplus=cat(3,norm_radial_profile_cherry_Sin_Cplus,norm_radial_profile_cherry);
                                norm_slice_profile_gfp_Sin_Cplus=cat(3,norm_slice_profile_gfp_Sin_Cplus,norm_slice_profile_gfp);
                                norm_slice_profile_cherry_Sin_Cplus=cat(3,norm_slice_profile_cherry_Sin_Cplus,norm_slice_profile_cherry);
                            elseif contains(file_path,'M')
                                norm_radial_profile_gfp_Sin_M=cat(3,norm_radial_profile_gfp_Sin_M,norm_radial_profile_gfp);
                                norm_radial_profile_cherry_Sin_M=cat(3,norm_radial_profile_cherry_Sin_M,norm_radial_profile_cherry);
                                norm_slice_profile_gfp_Sin_M=cat(3,norm_slice_profile_gfp_Sin_M,norm_slice_profile_gfp);
                                norm_slice_profile_cherry_Sin_M=cat(3,norm_slice_profile_cherry_Sin_M,norm_slice_profile_cherry);
                            end
                        end
                    end
                end
                display('Next image')
            end
        
        end
        
        %%% Change directory        
        cd ..
        
    end
    
    cd ..
    
    display('change of folder')
    
end

%%%%%%%%%% PLOTS %%%%%%%%%%%%%%% 

%%% PREPARE NEW MATRICES TO PLOT RESULTS => RAW FLUORESCENCE VALUES

%%%% 120 h %%%%%
%%%% RADIAL %%%
%%% SAMPLE
for i=1:size(norm_radial_profile_gfp_Sin_M,3)
    pp1=norm_radial_profile_gfp_Sin_M(:,:,i);
    pp2=norm_radial_profile_cherry_Sin_M(:,:,i);
    gfp_rad_Sin_M(:,:,i)=pp1;%(pp1-min(pp1(:)))/(max(pp1(:))-min(pp1(:)));
    cherry_rad_Sin_M(:,:,i)=pp2;%(pp2-min(pp2(:)))/(max(pp2(:))-min(pp2(:)));
end
%%% CONTROL +
for i=1:size(norm_radial_profile_gfp_Sin_Cplus,3)
    pp1=norm_radial_profile_gfp_Sin_Cplus(:,:,i);
    pp2=norm_radial_profile_cherry_Sin_Cplus(:,:,i);
    gfp_rad_Sin_Cplus(:,:,i)=pp1;%(pp1-min(pp1(:)))/(max(pp1(:))-min(pp1(:)));
    cherry_rad_Sin_Cplus(:,:,i)=pp2;%(pp2-min(pp2(:)))/(max(pp2(:))-min(pp2(:)));
end
%%% CONTROL -
for i=1:size(norm_radial_profile_gfp_Sin_Cmin,3)
    pp1=norm_radial_profile_gfp_Sin_Cmin(:,:,i);
    pp2=norm_radial_profile_cherry_Sin_Cmin(:,:,i);
    gfp_rad_Sin_Cmin(:,:,i)=pp1;%(pp1-min(pp1(:)))/(max(pp1(:))-min(pp1(:)));
    cherry_rad_Sin_Cmin(:,:,i)=pp2;%(pp2-min(pp2(:)))/(max(pp2(:))-min(pp2(:)));
end

%%%% SLICE Z %%%
%%% SAMPLE
for i=1:size(norm_slice_profile_gfp_Sin_M,3)
    pp1=norm_slice_profile_gfp_Sin_M(:,:,i);
    pp2=norm_slice_profile_cherry_Sin_M(:,:,i);
    gfp_sli_Sin_M(:,:,i)=pp1;%(pp1-min(pp1(:)))/(max(pp1(:))-min(pp1(:)));
    cherry_sli_Sin_M(:,:,i)=pp2;%(pp2-min(pp2(:)))/(max(pp2(:))-min(pp2(:)));
end
%%% CONTROL +
for i=1:size(norm_slice_profile_gfp_Sin_Cplus,3)
    pp1=norm_slice_profile_gfp_Sin_Cplus(:,:,i);
    pp2=norm_slice_profile_cherry_Sin_Cplus(:,:,i);
    gfp_sli_Sin_Cplus(:,:,i)=pp1;%(pp1-min(pp1(:)))/(max(pp1(:))-min(pp1(:)));
    cherry_sli_Sin_Cplus(:,:,i)=pp2;%(pp2-min(pp2(:)))/(max(pp2(:))-min(pp2(:)));
end
%%% CONTROL -
for i=1:size(norm_slice_profile_gfp_Sin_Cmin,3)
    pp1=norm_slice_profile_gfp_Sin_Cmin(:,:,i);
    pp2=norm_slice_profile_cherry_Sin_Cmin(:,:,i);
    gfp_sli_Sin_Cmin(:,:,i)=pp1;%(pp1-min(pp1(:)))/(max(pp1(:))-min(pp1(:)));
    cherry_sli_Sin_Cmin(:,:,i)=pp2;%(pp2-min(pp2(:)))/(max(pp2(:))-min(pp2(:)));
end

%%%%%%%% PLOT GENERATION %%%%%%%%%%

%%% MEAN %%%
%%% M %%%
%%% XY plane
figure(1),contourf(X_circle,Y_circle,mean(gfp_rad_Sin_M,3,'omitnan')),title('MEAN / GFP / M'),colormap(jet)%,caxis(limits_caxis)
%%% XZ plane
figure(2),contourf(X_slice,Z_slice,mean(gfp_sli_Sin_M,3,'omitnan')),title('MEAN / GFP / M'),colormap(jet)%,caxis(limits_caxis)

%%% CONTROL + %%%
%%% XY plane
figure(3),contourf(X_circle,Y_circle,mean(gfp_rad_Sin_Cplus,3,'omitnan')),title('MEAN / GFP / C+'),colormap(jet)%,caxis(limits_caxis)
%%% XZ plane
figure(4),contourf(X_slice,Z_slice,mean(gfp_sli_Sin_Cplus,3,'omitnan')),title('MEAN / GFP / C+'),colormap(jet)%,caxis(limits_caxis)

%%% CONTROL -
%%% XY plane
figure(5),contourf(X_circle,Y_circle,mean(gfp_rad_Sin_Cmin,3,'omitnan')),title('MEAN / GFP / C-'),colormap(jet)%,caxis(limits_caxis)
%%% XZ plane
figure(6),contourf(X_slice,Z_slice,mean(gfp_sli_Sin_Cmin,3,'omitnan')),title('MEAN VIEW / GFP / C-'),colormap(jet)%,caxis(limits_caxis)


%%% COEFFICIENT OF VARIATION (CV)
%%% M %%%
%%% XY plane
figure(7),contourf(X_circle,Y_circle,std(gfp_rad_Sin_M,0,3,'omitnan')./mean(gfp_rad_Sin_M,3,'omitnan')),title('COEFF VARIATION / GFP / M'),colormap(jet)%,caxis(limits_caxis)
%%% XZ plane
figure(8),contourf(X_slice,Z_slice,std(gfp_sli_Sin_M,0,3,'omitnan')./mean(gfp_sli_Sin_M,3,'omitnan')),title('COEFF VARIATION / GFP / GFP / M'),colormap(jet)%,caxis(limits_caxis)

%%% CONTROL + %%%
%%% XY plane
figure(9),contourf(X_circle,Y_circle,std(gfp_rad_Sin_Cplus,0,3,'omitnan')./mean(gfp_rad_Sin_Cplus,3,'omitnan')),title('COEFF VARIATION / GFP / C+'),colormap(jet)%,caxis(limits_caxis)
%%% XZ plane
figure(10),contourf(X_slice,Z_slice,std(gfp_sli_Sin_Cplus,0,3,'omitnan')./mean(gfp_sli_Sin_Cplus,3,'omitnan')),title('COEFF VARIATION / GFP C+'),colormap(jet)%,caxis(limits_caxis)

%%% CONTROL - %%%
%%% XY plane
figure(11),contourf(X_circle,Y_circle,std(gfp_rad_Sin_Cmin,0,3,'omitnan')./mean(gfp_rad_Sin_Cmin,3,'omitnan')),title('COEFF VARIATION / GFP / C-'),colormap(jet)%,caxis(limits_caxis)
%%% XZ plane
figure(12),contourf(X_slice,Z_slice,std(gfp_sli_Sin_Cmin,0,3,'omitnan')./mean(gfp_sli_Sin_Cmin,3,'omitnan')),title('COEFF VARIATION / GFP / C-'),colormap(jet)%,caxis(limits_caxis)


%%%% PREPARE NEW MATRICES TO PLOT RESULTS => NORMALIZED FLUORESCENCE VALUES
%%% 120 H %%
%%%% RADIAL %%%
%%% SAMPLE 
for i=1:size(norm_radial_profile_gfp_Sin_M,3)
    pp1=norm_radial_profile_gfp_Sin_M(:,:,i);
    pp2=norm_radial_profile_cherry_Sin_M(:,:,i);
    gfp_rad_Sin_M(:,:,i)=(pp1-min(pp1(:)))/(max(pp1(:))-min(pp1(:)));
    cherry_rad_Sin_M(:,:,i)=(pp2-min(pp2(:)))/(max(pp2(:))-min(pp2(:)));
end
%%% CONTROL +
for i=1:size(norm_radial_profile_gfp_Sin_Cplus,3)
    pp1=norm_radial_profile_gfp_Sin_Cplus(:,:,i);
    pp2=norm_radial_profile_cherry_Sin_Cplus(:,:,i);
    gfp_rad_Sin_Cplus(:,:,i)=(pp1-min(pp1(:)))/(max(pp1(:))-min(pp1(:)));
    cherry_rad_Sin_Cplus(:,:,i)=(pp2-min(pp2(:)))/(max(pp2(:))-min(pp2(:)));
end
%%% CONTROL -
for i=1:size(norm_radial_profile_gfp_Sin_Cmin,3)
    pp1=norm_radial_profile_gfp_Sin_Cmin(:,:,i);
    pp2=norm_radial_profile_cherry_Sin_Cmin(:,:,i);
    gfp_rad_Sin_Cmin(:,:,i)=(pp1-min(pp1(:)))/(max(pp1(:))-min(pp1(:)));
    cherry_rad_Sin_Cmin(:,:,i)=(pp2-min(pp2(:)))/(max(pp2(:))-min(pp2(:)));
end

%%%% SLICE Z %%%
%%% SAMPLE
for i=1:size(norm_slice_profile_gfp_Sin_M,3)
    pp1=norm_slice_profile_gfp_Sin_M(:,:,i);
    pp2=norm_slice_profile_cherry_Sin_M(:,:,i);
    gfp_sli_Sin_M(:,:,i)=(pp1-min(pp1(:)))/(max(pp1(:))-min(pp1(:)));
    cherry_sli_Sin_M(:,:,i)=(pp2-min(pp2(:)))/(max(pp2(:))-min(pp2(:)));
end
%%% CONTROL +
for i=1:size(norm_slice_profile_gfp_Sin_Cplus,3)
    pp1=norm_slice_profile_gfp_Sin_Cplus(:,:,i);
    pp2=norm_slice_profile_cherry_Sin_Cplus(:,:,i);
    gfp_sli_Sin_Cplus(:,:,i)=(pp1-min(pp1(:)))/(max(pp1(:))-min(pp1(:)));
    cherry_sli_Sin_Cplus(:,:,i)=(pp2-min(pp2(:)))/(max(pp2(:))-min(pp2(:)));
end
%%% CONTROL -
for i=1:size(norm_slice_profile_gfp_Sin_Cmin,3)
    pp1=norm_slice_profile_gfp_Sin_Cmin(:,:,i);
    pp2=norm_slice_profile_cherry_Sin_Cmin(:,:,i);
    gfp_sli_Sin_Cmin(:,:,i)=(pp1-min(pp1(:)))/(max(pp1(:))-min(pp1(:)));
    cherry_sli_Sin_Cmin(:,:,i)=(pp2-min(pp2(:)))/(max(pp2(:))-min(pp2(:)));
end

%%%%%%%% PLOT GENERATION %%%%%%%%%%

%%% MEAN %%%
%%% M %%%
%%% XY plane
figure(13),contourf(X_circle,Y_circle,mean(gfp_rad_Sin_M,3,'omitnan')),title('NORMALIZED / MEAN / GFP / M'),colormap(jet)%,caxis(limits_caxis)
%%% XZ plane
figure(14),contourf(X_slice,Z_slice,mean(gfp_sli_Sin_M,3,'omitnan')),title('NORMALIZED / MEAN / GFP / M'),colormap(jet)%,caxis(limits_caxis)

%%% CONTROL + %%%
%%% XY plane
figure(15),contourf(X_circle,Y_circle,mean(gfp_rad_Sin_Cplus,3,'omitnan')),title('NORMALIZED / MEAN / GFP / C+'),colormap(jet)%,caxis(limits_caxis)
%%% XZ plane
figure(16),contourf(X_slice,Z_slice,mean(gfp_sli_Sin_Cplus,3,'omitnan')),title('NORMALIZED / MEAN / GFP / C+'),colormap(jet)%,caxis(limits_caxis)

%%% CONTROL -
%%% XY plane
figure(17),contourf(X_circle,Y_circle,mean(gfp_rad_Sin_Cmin,3,'omitnan')),title('NORMALIZED / MEAN / GFP / C-'),colormap(jet)%,caxis(limits_caxis)
%%% XZ plane
figure(18),contourf(X_slice,Z_slice,mean(gfp_sli_Sin_Cmin,3,'omitnan')),title('NORMALIZED / MEAN / GFP / C-'),colormap(jet)%,caxis(limits_caxis)

